#是否作为守护进程运行
daemonize yes
#如以后台进程运行,则需指定一个pid,默认为/var/run/redis.pid
pidfile redis.pid
#绑定主机IP,默认值为127.0.0.1
bind 127.0.0.1
#Redis默认监听端口
port 6379
#客户端闲置多少秒后,断开连接,默认为300（秒）
timeout 0
#日志记录等级,有4个可选值,debug,verbose（默认值）,notice,warning
loglevel verbose
#指定日志输出的文件名,默认值为stdout,也可设为/dev/null屏蔽日志
logfile stdout
#可用数据库数,默认值为16,默认数据库为0
databases 16
#保存数据到disk的策略
#当有一条Keys数据被改变是,900秒刷新到disk一次
save 900 1
#当有10条Keys数据被改变时,300秒刷新到disk一次
save 300 10
#当有1w条keys数据被改变时,60秒刷新到disk一次
save 60 10000
#当dump .rdb数据库的时候是否压缩数据对象
rdbcompression yes
#本地数据库文件名,默认值为dump.rdb
dbfilename dump.rdb
#本地数据库存放路径,默认值为 ./
dir /var/lib/redis/

########### Replication #####################
#Redis的复制配置
slaveof <masterip> <masterport> 当本机为从服务时,设置主服务的IP及端口
masterauth <master-password> 当本机为从服务时,设置主服务的连接密码
#连接密码
requirepass foobared
#最大客户端连接数,默认不限制
maxclients 128
#最大内存使用设置,达到最大内存设置后,Redis会先尝试清除已到期或即将到期的Key,当此方法处理后,依然到达最大内存设置,将无法再进行写入操作
#从性能和实施的角度考虑,可以为物理内存3/4
maxmemory <bytes>
#内存不足时数据清除策略,默认为"volatile-lru",如果数据的过期不会对"应用系统"带来异常,且系统中write操作比较密集,建议采取"allkeys-lru"
#所有可用清除策略如下
#  volatile-lru: 对"过期集合"中的数据采取LRU(近期最少使用)算法.如果对key使用"expire"指令指定了过期时间,那么此key将会被添加到"过期集合"中.将已经过期/LRU的数据优先移除.如果"过期集合"中全部移除仍不能满足内存需求,将OOM.
#  allkeys-lru: 对所有的数据,采用LRU算法
#  volatile-random: 对"过期集合"中的数据采取"随即选取"算法,并移除选中的K-V,直到"内存足够"为止. 如果如果"过期集合"中全部移除全部移除仍不能满足,将OOM
#  allkeys-random: 对所有的数据,采取"随机选取"算法,并移除选中的K-V,直到"内存足够"为止
#  volatile-ttl: 对"过期集合"中的数据采取TTL算法(最小存活时间),移除即将过期的数据.
#  noeviction: 不做任何干扰操作,直接返回OOM异常
maxmemory-policy allkeys-lru
#是否在每次更新操作后进行日志记录,如果不开启,可能会在断电时导致一段时间内的数据丢失.因为redis本身同步数据文件是按上面save条件来同步的,所以有的数据会在一段时间内只存在于内存中.默认值为no
appendonly no
#更新日志文件名,默认值为appendonly.aof
appendfilename appendonly.aof
#更新日志条件
#  no: 等操作系统进行数据缓存同步到磁盘
#  always: 每次更新操作后手动调用fsync()将数据写到磁盘
#  everysec: 每秒同步一次（默认值）
appendfsync everysec

################ VIRTUAL MEMORY ###########
#是否开启VM功能,默认值为no
vm-enabled no
#虚拟内存文件路径,默认值为/tmp/redis.swap,不可多个Redis实例共享
vm-swap-file /tmp/redis.swap
# 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的 (Redis的索引数据就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘.默认值为0.
vm-max-memory 0
vm-page-size 32
vm-pages 134217728
vm-max-threads 4

############# ADVANCED CONFIG ###############
glueoutputbuf yes
hash-max-zipmap-entries 64
hash-max-zipmap-value 512
#是否重置Hash表
activerehashing yes
注意：Redis官方文档对VM的使用提出了一些建议:
当你的key很小而value很大时,使用VM的效果会比较好.因为这样节约的内存比较大.
当你的key不小时,可以考虑使用一些非常方法将很大的key变成很大的value,比如你可以考虑将key,value组合成一个新的value.
最好使用linux ext3 等对稀疏文件支持比较好的文件系统保存你的swap文件.
vm-max-threads这个参数,可以设置访问swap文件的线程数,设置最好不要超过机器的核数.如果设置为0,那么所有对swap文件的操作都是串行的.可能会造成比较长时间的延迟,但是对数据完整性有很好的保证.

2. 调整系统内核参数
如果内存情况比较紧张的话,需要设定内核参数：
echo 1 > /proc/sys/vm/overcommit_memory
这里说一下这个配置的含义：/proc/sys/vm/overcommit_memory
该文件指定了内核针对内存分配的策略,其值可以是0、1、2.
0,表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存,内存申请允许；否则,内存申请失败,并把错误返回给应用进程.
1,表示内核允许分配所有的物理内存,而不管当前的内存状态如何.
2,表示内核允许分配超过所有物理内存和交换空间总和的内存
Redis 在dump数据的时候,会fork出一个子进程,理论上child进程所占用的内存和parent是一样的,比如parent占用的内存为 8G,这个时候也要同样分配8G的内存给child, 如果内存无法负担,往往会造成redis服务器的down机或者IO负载过高,效率下降.所以这里比较优化的内存分配策略应该设置为 1（表示内核允许分配所有的物理内存,而不管当前的内存状态如何）